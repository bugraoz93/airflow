# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

from __future__ import annotations

import datetime
import json
from typing import TYPE_CHECKING, Any, TypeVar

import httpx
import structlog
from pydantic import BaseModel

from airflowctl.exceptions import AirflowCtlConnectionException

if TYPE_CHECKING:
    from airflowctl.api.client import Client
    from airflowctl.api.datamodels.auth_generated import LoginBody, LoginResponse
    from airflowctl.api.datamodels.generated import (
        AssetAliasCollectionResponse,
        AssetAliasResponse,
        AssetCollectionResponse,
        AssetEventResponse,
        AssetResponse,
        BackfillCollectionResponse,
        BackfillPostBody,
        BackfillResponse,
        BulkBodyConnectionBody,
        BulkBodyPoolBody,
        BulkBodyVariableBody,
        BulkResponse,
        Config,
        ConnectionBody,
        ConnectionCollectionResponse,
        ConnectionResponse,
        ConnectionTestResponse,
        CreateAssetEventsBody,
        DAGCollectionResponse,
        DAGDetailsResponse,
        DAGPatchBody,
        DAGResponse,
        DAGRunCollectionResponse,
        DAGRunResponse,
        DagStatsCollectionResponse,
        DAGTagCollectionResponse,
        DAGVersionCollectionResponse,
        DagVersionResponse,
        DAGWarningCollectionResponse,
        ImportErrorCollectionResponse,
        ImportErrorResponse,
        JobCollectionResponse,
        PoolBody,
        PoolCollectionResponse,
        PoolPatchBody,
        PoolResponse,
        ProviderCollectionResponse,
        QueuedEventCollectionResponse,
        QueuedEventResponse,
        TriggerDAGRunPostBody,
        VariableBody,
        VariableCollectionResponse,
        VariableResponse,
        VersionInfo,
        XComCollectionResponse,
        XComResponseNative,
    )

log = structlog.get_logger(logger_name=__name__)

T = TypeVar("T", bound=BaseModel)


# Generic Server Response Error
class ServerResponseError(httpx.HTTPStatusError):
    """Server response error (Generic)."""

    @classmethod
    def from_response(cls, response: httpx.Response) -> ServerResponseError | None:
        if response.status_code < 400:
            return None

        if response.headers.get("content-type") != "application/json":
            return None

        if 400 <= response.status_code < 500:
            response.read()
            return cls(
                message=f"Client error message: {response.json()}",
                request=response.request,
                response=response,
            )

        msg = response.json()

        self = cls(message=msg, request=response.request, response=response)
        return self


def _check_flag_and_exit_if_server_response_error(func):
    """Return decorator to check for ServerResponseError and exit if the server is not running."""

    def _exit_if_server_response_error(response: Any | ServerResponseError):
        if isinstance(response, ServerResponseError):
            raise response
        return response

    def wrapped(self, *args, **kwargs):
        try:
            if self.exit_in_error:
                return _exit_if_server_response_error(response=func(self, *args, **kwargs))
            return func(self, *args, **kwargs)
        except httpx.ConnectError as e:
            if "Connection refused" in str(e):
                raise AirflowCtlConnectionException("Connection refused. Is the API server running?")
            raise AirflowCtlConnectionException(f"Connection error: {e}")

    return wrapped


def smart_exclude_none(model: BaseModel, schema_model: BaseModel) -> dict:
    """
    Exclude None values from a model and check if field is required in current schema.

    Use this method when you need model_dump as it's controlling the schema compatibility.

    :param model: The Pydantic model instance to be dumped.
    :param schema_model: The Pydantic model class that defines the schema to check against.
    :return: A dictionary representation of the model with None values excluded, but including required fields set to None if they were missing.
    """
    model_dict = model.model_dump(mode="json", exclude_none=True)
    for field_name, field in schema_model.model_fields.items():
        if field_name not in model_dict and field.is_required:
            # We are setting missing but required fields to None to fit schema perfectly
            model_dict[field_name] = None
    return model_dict


# ClientKind CLI or NO_AUTH
class BaseOperations:
    """
    Base class for operations.

    This class is used to decorate all callable methods with a check for ServerResponseError.
    Set exit_in_error false to not exit.
    """

    __slots__ = ("client", "response", "exit_in_error", "ctl_gen_schemas")

    def __init__(
        self,
        client: Client,
        response=None,
        exit_in_error: bool = True,
    ):
        self.client = client
        self.response = response
        self.exit_in_error = exit_in_error
        self.ctl_gen_schemas = self.client.ctl_gen_schemas

    def __init_subclass__(cls, **kwargs):
        """Decorate all callable methods with a check for ServerResponseError and exit if the server is not running."""
        super().__init_subclass__(**kwargs)
        for attr, value in cls.__dict__.items():
            if callable(value):
                setattr(cls, attr, _check_flag_and_exit_if_server_response_error(value))

    def execute_list(
        self,
        *,
        path: str,
        data_model: type[T],
        offset: int = 0,
        limit: int = 50,
        params: dict | None = None,
    ) -> T | ServerResponseError:
        shared_params = {**(params or {})}
        self.response = self.client.get(path, params=shared_params)
        first_pass = data_model.model_validate_json(self.response.content)
        total_entries = first_pass.total_entries  # type: ignore[attr-defined]
        if total_entries < limit:
            return first_pass
        found_key = ""
        for key, value in first_pass.model_dump().items():
            if key != "total_entries" and isinstance(value, list):
                found_key = key
                break
        entry_list = getattr(first_pass, found_key)
        offset = offset + limit
        while offset < total_entries:
            self.response = self.client.get(path, params={**shared_params, "offset": offset})
            entry = data_model.model_validate_json(self.response.content)
            offset = offset + limit
            entry_list.extend(getattr(entry, found_key))
        obj = data_model(**{found_key: entry_list, "total_entries": total_entries})
        return data_model.model_validate(obj.model_dump())


# ClientKind Auth
class BaseAuthOperations:
    """
    Base class for auth operations.

    This class is used to decorate all callable methods with a check for ServerResponseError.
    Set exit_in_error false to not exit.
    """

    __slots__ = ("client", "response", "exit_in_error", "ctl_gen_schemas")

    def __init__(self, client: Client):
        self.client = client
        self.ctl_gen_schemas = self.client.ctl_gen_schemas


# Login operations
class LoginOperations(BaseAuthOperations):
    """Login operations."""

    def login_with_username_and_password(self, login: LoginBody) -> LoginResponse | ServerResponseError:
        """Login to the API server."""
        try:
            return self.ctl_gen_schemas.LoginResponse.model_validate_json(
                self.client.post("/token/cli", json=login.model_dump(mode="json", exclude_none=True)).content
            )
        except ServerResponseError as e:
            raise e


# Operations
class AssetsOperations(BaseOperations):
    """Assets operations."""

    def get(self, asset_id: str) -> AssetResponse | ServerResponseError:
        """Get an asset from the API server."""
        try:
            self.response = self.client.get(f"assets/{asset_id}")
            return self.ctl_gen_schemas.AssetResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def get_by_alias(self, alias: str) -> AssetAliasResponse | ServerResponseError:
        """Get an asset by alias from the API server."""
        try:
            self.response = self.client.get(f"assets/aliases/{alias}")
            return self.ctl_gen_schemas.AssetAliasResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list(self) -> AssetCollectionResponse | ServerResponseError:
        """List all assets from the API server."""
        return super().execute_list(path="assets", data_model=self.ctl_gen_schemas.AssetCollectionResponse)

    def list_by_alias(self) -> AssetAliasCollectionResponse | ServerResponseError:
        """List all assets by alias from the API server."""
        return super().execute_list(
            path="/assets/aliases", data_model=self.ctl_gen_schemas.AssetAliasCollectionResponse
        )

    def create_event(
        self, asset_event_body: CreateAssetEventsBody
    ) -> AssetEventResponse | ServerResponseError:
        """Create an asset event."""
        try:
            # Ensure extra is initialised before sent to API
            if asset_event_body.extra is None:
                asset_event_body.extra = {}
            self.response = self.client.post(
                "assets/events",
                json=smart_exclude_none(asset_event_body, self.ctl_gen_schemas.CreateAssetEventsBody),
            )
            return self.ctl_gen_schemas.AssetEventResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def materialize(self, asset_id: str) -> DAGRunResponse | ServerResponseError:
        """Materialize an asset."""
        try:
            self.response = self.client.post(f"assets/{asset_id}/materialize")
            return self.ctl_gen_schemas.DAGRunResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def get_queued_events(self, asset_id: str) -> QueuedEventCollectionResponse | ServerResponseError:
        """Get queued events for an asset."""
        try:
            self.response = self.client.get(f"assets/{asset_id}/queuedEvents")
            return self.ctl_gen_schemas.QueuedEventCollectionResponse.model_validate_json(
                self.response.content
            )
        except ServerResponseError as e:
            raise e

    def get_dag_queued_events(
        self, dag_id: str, before: str
    ) -> QueuedEventCollectionResponse | ServerResponseError:
        """Get queued events for a dag."""
        try:
            self.response = self.client.get(f"dags/{dag_id}/assets/queuedEvents", params={"before": before})
            return self.ctl_gen_schemas.QueuedEventCollectionResponse.model_validate_json(
                self.response.content
            )
        except ServerResponseError as e:
            raise e

    def get_dag_queued_event(self, dag_id: str, asset_id: str) -> QueuedEventResponse | ServerResponseError:
        """Get a queued event for a dag."""
        try:
            self.response = self.client.get(f"dags/{dag_id}/assets/{asset_id}/queuedEvents")
            return self.ctl_gen_schemas.QueuedEventResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def delete_queued_events(self, asset_id: str) -> str | ServerResponseError:
        """Delete a queued event for an asset."""
        try:
            self.client.delete(f"assets/{asset_id}/queuedEvents/")
            return asset_id
        except ServerResponseError as e:
            raise e

    def delete_dag_queued_events(self, dag_id: str, before: str) -> str | ServerResponseError:
        """Delete a queued event for a dag."""
        try:
            self.client.delete(f"assets/dags/{dag_id}/queuedEvents", params={"before": before})
            return dag_id
        except ServerResponseError as e:
            raise e

    def delete_queued_event(self, dag_id: str, asset_id: str) -> str | ServerResponseError:
        """Delete a queued event for a dag."""
        try:
            self.client.delete(f"assets/dags/{dag_id}/assets/{asset_id}/queuedEvents/")
            return asset_id
        except ServerResponseError as e:
            raise e


class BackfillOperations(BaseOperations):
    """Backfill operations."""

    def create(self, backfill: BackfillPostBody) -> BackfillResponse | ServerResponseError:
        """Create a backfill."""
        try:
            self.response = self.client.post(
                "backfills", data=smart_exclude_none(backfill, self.ctl_gen_schemas.BackfillPostBody)
            )
            return self.ctl_gen_schemas.BackfillResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def create_dry_run(self, backfill: BackfillPostBody) -> BackfillResponse | ServerResponseError:
        """Create a dry run backfill."""
        try:
            self.response = self.client.post(
                "backfills/dry_run", data=smart_exclude_none(backfill, self.ctl_gen_schemas.BackfillPostBody)
            )
            return self.ctl_gen_schemas.BackfillResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def get(self, backfill_id: str) -> BackfillResponse | ServerResponseError:
        """Get a backfill."""
        try:
            self.response = self.client.get(f"backfills/{backfill_id}")
            return self.ctl_gen_schemas.BackfillResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list(self, dag_id: str) -> BackfillCollectionResponse | ServerResponseError:
        """List all backfills."""
        params = {"dag_id": dag_id}
        return super().execute_list(
            path="backfills", data_model=self.ctl_gen_schemas.BackfillCollectionResponse, params=params
        )

    def pause(self, backfill_id: str) -> BackfillResponse | ServerResponseError:
        """Pause a backfill."""
        try:
            self.response = self.client.post(f"backfills/{backfill_id}/pause")
            return self.ctl_gen_schemas.BackfillResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def unpause(self, backfill_id: str) -> BackfillResponse | ServerResponseError:
        """Unpause a backfill."""
        try:
            self.response = self.client.post(f"backfills/{backfill_id}/unpause")
            return self.ctl_gen_schemas.BackfillResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def cancel(self, backfill_id: str) -> BackfillResponse | ServerResponseError:
        """Cancel a backfill."""
        try:
            self.response = self.client.post(f"backfills/{backfill_id}/cancel")
            return self.ctl_gen_schemas.BackfillResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e


class ConfigOperations(BaseOperations):
    """Config operations."""

    def get(self, section: str, option: str) -> Config | ServerResponseError:
        """Get a config from the API server."""
        try:
            self.response = self.client.get(f"/config/section/{section}/option/{option}")
            return self.ctl_gen_schemas.Config.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list(self) -> Config | ServerResponseError:
        """List all configs from the API server."""
        try:
            self.response = self.client.get("/config")
            return self.ctl_gen_schemas.Config.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e


class ConnectionsOperations(BaseOperations):
    """Connection operations."""

    def get(self, conn_id: str) -> ConnectionResponse | ServerResponseError:
        """Get a connection from the API server."""
        try:
            self.response = self.client.get(f"connections/{conn_id}")
            return self.ctl_gen_schemas.ConnectionResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list(self) -> ConnectionCollectionResponse | ServerResponseError:
        """List all connections from the API server."""
        return super().execute_list(
            path="connections", data_model=self.ctl_gen_schemas.ConnectionCollectionResponse
        )

    def create(
        self,
        connection: ConnectionBody,
    ) -> ConnectionResponse | ServerResponseError:
        """Create a connection."""
        try:
            self.response = self.client.post(
                "connections", json=smart_exclude_none(connection, self.ctl_gen_schemas.ConnectionBody)
            )
            return self.ctl_gen_schemas.ConnectionResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def bulk(self, connections: BulkBodyConnectionBody) -> BulkResponse | ServerResponseError:
        """CRUD multiple connections."""
        try:
            self.response = self.client.patch(
                "connections",
                json=smart_exclude_none(connections, self.ctl_gen_schemas.BulkBodyConnectionBody),
            )
            return self.ctl_gen_schemas.BulkResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def create_defaults(self) -> None | ServerResponseError:
        """Create default connections."""
        try:
            self.response = self.client.post("connections/defaults")
            return None
        except ServerResponseError as e:
            raise e

    def delete(self, conn_id: str) -> str | ServerResponseError:
        """Delete a connection."""
        try:
            self.client.delete(f"connections/{conn_id}")
            return conn_id
        except ServerResponseError as e:
            raise e

    def update(
        self,
        connection: ConnectionBody,
    ) -> ConnectionResponse | ServerResponseError:
        """Update a connection."""
        try:
            self.response = self.client.patch(
                f"connections/{connection.connection_id}",
                json=smart_exclude_none(connection, self.ctl_gen_schemas.ConnectionBody),
            )
            return self.ctl_gen_schemas.ConnectionResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def test(
        self,
        connection: ConnectionBody,
    ) -> ConnectionTestResponse | ServerResponseError:
        """Test a connection."""
        try:
            self.response = self.client.post(
                "connections/test", json=smart_exclude_none(connection, self.ctl_gen_schemas.ConnectionBody)
            )
            return self.ctl_gen_schemas.ConnectionTestResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e


class DagsOperations(BaseOperations):
    """Dags operations."""

    def get(self, dag_id: str) -> DAGResponse | ServerResponseError:
        """Get a DAG."""
        try:
            self.response = self.client.get(f"dags/{dag_id}")
            return self.ctl_gen_schemas.DAGResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def get_details(self, dag_id: str) -> DAGDetailsResponse | ServerResponseError:
        """Get a DAG details."""
        try:
            self.response = self.client.get(f"dags/{dag_id}/details")
            return self.ctl_gen_schemas.DAGDetailsResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def get_tags(self) -> DAGTagCollectionResponse | ServerResponseError:
        """Get all DAG tags."""
        return super().execute_list(path="dagTags", data_model=self.ctl_gen_schemas.DAGTagCollectionResponse)

    def list(self) -> DAGCollectionResponse | ServerResponseError:
        """List DAGs."""
        return super().execute_list(path="dags", data_model=self.ctl_gen_schemas.DAGCollectionResponse)

    def update(self, dag_id: str, dag_body: DAGPatchBody) -> DAGResponse | ServerResponseError:
        try:
            self.response = self.client.patch(
                f"dags/{dag_id}", json=smart_exclude_none(dag_body, self.ctl_gen_schemas.DAGPatchBody)
            )
            return self.ctl_gen_schemas.DAGResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def delete(self, dag_id: str) -> str | ServerResponseError:
        try:
            self.client.delete(f"dags/{dag_id}")
            return dag_id
        except ServerResponseError as e:
            raise e

    def get_import_error(self, import_error_id: str) -> ImportErrorResponse | ServerResponseError:
        try:
            self.response = self.client.get(f"importErrors/{import_error_id}")
            return self.ctl_gen_schemas.ImportErrorResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list_import_errors(self) -> ImportErrorCollectionResponse | ServerResponseError:
        return super().execute_list(
            path="importErrors", data_model=self.ctl_gen_schemas.ImportErrorCollectionResponse
        )

    def get_stats(self, dag_ids: list) -> DagStatsCollectionResponse | ServerResponseError:  # type: ignore
        try:
            self.response = self.client.get("dagStats", params={"dag_ids": dag_ids})
            return self.ctl_gen_schemas.DagStatsCollectionResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def get_version(self, dag_id: str, version_number: int) -> DagVersionResponse | ServerResponseError:
        try:
            self.response = self.client.get(f"dags/{dag_id}/dagVersions/{version_number}")
            return self.ctl_gen_schemas.DagVersionResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list_version(self, dag_id: str) -> DAGVersionCollectionResponse | ServerResponseError:
        return super().execute_list(
            path=f"dags/{dag_id}/dagVersions", data_model=self.ctl_gen_schemas.DAGVersionCollectionResponse
        )

    def list_warning(self) -> DAGWarningCollectionResponse | ServerResponseError:
        return super().execute_list(
            path="dagWarnings", data_model=self.ctl_gen_schemas.DAGWarningCollectionResponse
        )

    def trigger(
        self, dag_id: str, trigger_dag_run: TriggerDAGRunPostBody
    ) -> DAGRunResponse | ServerResponseError:
        """Create a dag run."""
        if trigger_dag_run.conf is None:
            trigger_dag_run.conf = {}
        try:
            self.response = self.client.post(
                f"dags/{dag_id}/dagRuns",
                json=smart_exclude_none(trigger_dag_run, self.ctl_gen_schemas.TriggerDAGRunPostBody),
            )
            return self.ctl_gen_schemas.DAGRunResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e


class DagRunOperations(BaseOperations):
    """Dag run operations."""

    def get(self, dag_id: str, dag_run_id: str) -> DAGRunResponse | ServerResponseError:
        """Get a dag run."""
        try:
            self.response = self.client.get(f"/dags/{dag_id}/dagRuns/{dag_run_id}")
            return self.ctl_gen_schemas.DAGRunResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list(
        self,
        dag_id: str,
        start_date: datetime.datetime,
        end_date: datetime.datetime,
        state: str,
        limit: int,
    ) -> DAGRunCollectionResponse | ServerResponseError:
        """List all dag runs."""
        params = {
            "start_date": start_date,
            "end_date": end_date,
            "state": state,
            "limit": limit,
            "dag_id": dag_id,
        }
        return super().execute_list(
            path=f"/dags/{dag_id}/dagRuns",
            data_model=self.ctl_gen_schemas.DAGRunCollectionResponse,
            params=params,
        )


class JobsOperations(BaseOperations):
    """Job operations."""

    def list(
        self, job_type: str, hostname: str, is_alive: bool
    ) -> JobCollectionResponse | ServerResponseError:
        """List all jobs."""
        params = {"job_type": job_type, "hostname": hostname, "is_alive": is_alive}
        return super().execute_list(
            path="jobs", data_model=self.ctl_gen_schemas.JobCollectionResponse, params=params
        )


class PoolsOperations(BaseOperations):
    """Pool operations."""

    def get(self, pool_name: str) -> PoolResponse | ServerResponseError:
        """Get a pool."""
        try:
            self.response = self.client.get(f"pools/{pool_name}")
            return self.ctl_gen_schemas.PoolResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list(self) -> PoolCollectionResponse | ServerResponseError:
        """List all pools."""
        return super().execute_list(path="pools", data_model=self.ctl_gen_schemas.PoolCollectionResponse)

    def create(self, pool: PoolBody) -> PoolResponse | ServerResponseError:
        """Create a pool."""
        try:
            self.response = self.client.post(
                "pools", json=smart_exclude_none(pool, self.ctl_gen_schemas.PoolBody)
            )
            return self.ctl_gen_schemas.PoolResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def bulk(self, pools: BulkBodyPoolBody) -> BulkResponse | ServerResponseError:
        """CRUD multiple pools."""
        try:
            self.response = self.client.patch(
                "pools", json=smart_exclude_none(pools, self.ctl_gen_schemas.BulkBodyPoolBody)
            )
            return self.ctl_gen_schemas.BulkResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def delete(self, pool: str) -> str | ServerResponseError:
        """Delete a pool."""
        try:
            self.client.delete(f"pools/{pool}")
            return pool
        except ServerResponseError as e:
            raise e

    def update(self, pool_body: PoolPatchBody) -> PoolResponse | ServerResponseError:
        """Update a pool."""
        try:
            self.response = self.client.patch(
                f"pools/{pool_body.pool}",
                json=smart_exclude_none(pool_body, self.ctl_gen_schemas.PoolPatchBody),
            )
            return self.ctl_gen_schemas.PoolResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e


class ProvidersOperations(BaseOperations):
    """Provider operations."""

    def list(self) -> ProviderCollectionResponse | ServerResponseError:
        """List all providers."""
        return super().execute_list(
            path="providers", data_model=self.ctl_gen_schemas.ProviderCollectionResponse
        )


class VariablesOperations(BaseOperations):
    """Variable operations."""

    def get(self, variable_key: str) -> VariableResponse | ServerResponseError:
        """Get a variable."""
        try:
            self.response = self.client.get(f"variables/{variable_key}")
            return self.ctl_gen_schemas.VariableResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list(self) -> VariableCollectionResponse | ServerResponseError:
        """List all variables."""
        return super().execute_list(
            path="variables", data_model=self.ctl_gen_schemas.VariableCollectionResponse
        )

    def create(self, variable: VariableBody) -> VariableResponse | ServerResponseError:
        """Create a variable."""
        try:
            print(self.ctl_gen_schemas)
            self.response = self.client.post(
                "variables", json=smart_exclude_none(variable, self.ctl_gen_schemas.VariableBody)
            )
            return self.ctl_gen_schemas.VariableResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def bulk(self, variables: BulkBodyVariableBody) -> BulkResponse | ServerResponseError:
        """CRUD multiple variables."""
        try:
            self.response = self.client.patch(
                "variables", json=smart_exclude_none(variables, self.ctl_gen_schemas.BulkBodyVariableBody)
            )
            return self.ctl_gen_schemas.BulkResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def delete(self, variable_key: str) -> str | ServerResponseError:
        """Delete a variable."""
        try:
            self.client.delete(f"variables/{variable_key}")
            return variable_key
        except ServerResponseError as e:
            raise e

    def update(self, variable: VariableBody) -> VariableResponse | ServerResponseError:
        """Update a variable."""
        try:
            self.response = self.client.patch(
                f"variables/{variable.key}",
                json=smart_exclude_none(variable, self.ctl_gen_schemas.VariableBody),
            )
            return self.ctl_gen_schemas.VariableResponse.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e


class VersionOperations(BaseOperations):
    """Version operations."""

    def get(self) -> VersionInfo | ServerResponseError:
        """Get the version."""
        try:
            self.response = self.client.get("version")
            return self.ctl_gen_schemas.VersionInfo.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e


class XComOperations(BaseOperations):
    """XCom operations."""

    def get(
        self,
        dag_id: str,
        dag_run_id: str,
        task_id: str,
        key: str,
        map_index: int = None,  # type: ignore
    ) -> XComResponseNative | ServerResponseError:
        """Get an XCom entry."""
        try:
            params: dict[str, Any] = {}
            if map_index is not None:
                params["map_index"] = map_index
            self.response = self.client.get(
                f"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}",
                params=params,
            )
            return self.ctl_gen_schemas.XComResponseNative.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def list(
        self,
        dag_id: str,
        dag_run_id: str,
        task_id: str,
        map_index: int = None,  # type: ignore
        key: str = None,  # type: ignore
    ) -> XComCollectionResponse | ServerResponseError:
        """List XCom entries."""
        params: dict[str, Any] = {}
        if map_index is not None:
            params["map_index"] = map_index
        if key is not None:
            params["xcom_key"] = key
        return super().execute_list(
            path=f"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries",
            data_model=self.ctl_gen_schemas.XComCollectionResponse,
            params=params,
        )

    def add(
        self,
        dag_id: str,
        dag_run_id: str,
        task_id: str,
        key: str,
        value: str,
        map_index: int = None,  # type: ignore
    ) -> XComResponseNative | ServerResponseError:
        """Add an XCom entry."""
        try:
            parsed_value = json.loads(value)
        except (ValueError, TypeError):
            parsed_value = value

        body_dict: dict[str, Any] = {"key": key, "value": parsed_value}
        if map_index is not None:
            body_dict["map_index"] = map_index
        body = self.ctl_gen_schemas.XComCreateBody(**body_dict)
        try:
            self.response = self.client.post(
                f"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries",
                json=smart_exclude_none(body, self.ctl_gen_schemas.XComCreateBody),
            )
            return self.ctl_gen_schemas.XComResponseNative.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e

    def edit(
        self,
        dag_id: str,
        dag_run_id: str,
        task_id: str,
        key: str,
        value: str,
        map_index: int = None,  # type: ignore
    ) -> XComResponseNative | ServerResponseError:
        """Edit an XCom entry."""
        try:
            parsed_value = json.loads(value)
        except (ValueError, TypeError):
            parsed_value = value

        body_dict: dict[str, Any] = {"value": parsed_value}
        if map_index is not None:
            body_dict["map_index"] = map_index
        body = self.ctl_gen_schemas.XComUpdateBody(**body_dict)
        try:
            self.response = self.client.patch(
                f"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}",
                json=smart_exclude_none(body, self.ctl_gen_schemas.XComUpdateBody),
            )
            return self.ctl_gen_schemas.XComResponseNative.model_validate_json(self.response.content)
        except ServerResponseError as e:
            raise e
